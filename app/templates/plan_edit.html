{% extends "base.html" %}

{% block title %}Edit Lesson Plan - Cycle Planner{% endblock %}

{% block content %}
<div id="plan-editor" class="space-y-6">
    <!-- AI Generation Notice (shown after AI generation) -->
    <div id="spotify-prompt" class="hidden bg-amber-50 border border-amber-200 rounded-lg p-4">
        <div class="flex gap-3">
            <div class="flex-shrink-0">
                <svg class="w-6 h-6 text-amber-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"/>
                </svg>
            </div>
            <div class="flex-1">
                <h3 class="font-semibold text-amber-800">Review AI-Generated Plan</h3>
                <p class="text-sm text-amber-700 mt-1">
                    <strong>AI suggestions may be inaccurate.</strong> Song names, artists, and durations are often incorrect.
                    Please review and manually edit the plan as needed.
                </p>
                <p class="text-sm text-amber-700 mt-2">
                    <strong>For playback:</strong> Connect to Spotify, then use the <span class="inline-flex items-center"><svg class="w-4 h-4 text-green-500 mx-1" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>Spotify picker</span> to select songs and populate the correct duration.
                </p>
            </div>
            <button onclick="dismissSpotifyPrompt()" class="text-amber-400 hover:text-amber-600">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- Header -->
    <div class="bg-white rounded-lg shadow-md p-6">
        <div class="flex justify-between items-start gap-4">
            <div class="flex-1">
                <label class="block text-sm font-medium text-gray-700 mb-1">Theme</label>
                <input
                    type="text"
                    id="plan-theme"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 text-xl font-bold"
                    placeholder="Class theme..."
                >
            </div>
            <div class="text-right">
                <label class="block text-sm font-medium text-gray-700 mb-1">Total Duration</label>
                <span id="total-duration" class="text-2xl font-bold text-indigo-600">0 min</span>
            </div>
        </div>
        <!-- Notes -->
        <div class="mt-4">
            <label class="block text-sm font-medium text-gray-700 mb-1">Notes</label>
            <textarea
                id="plan-notes"
                rows="2"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500 text-sm"
                placeholder="Additional notes for this class..."
            ></textarea>
        </div>
    </div>

    <!-- Segments -->
    <div class="bg-white rounded-lg shadow-md p-6">
        <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-bold text-gray-800">Segments</h2>
            <button
                onclick="addSegment()"
                class="bg-green-600 text-white px-3 py-1 rounded-md hover:bg-green-700 text-sm"
            >
                + Add Segment
            </button>
        </div>

        <div id="segments-container" class="space-y-4">
            <!-- Segments will be populated by JS -->
        </div>
    </div>

    <!-- Actions -->
    <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center gap-3 print:hidden">
        <div id="back-links">
            <a href="/" class="text-gray-600 hover:text-gray-800 text-sm">
                &larr; Generate New Plan
            </a>
        </div>
        <div class="flex gap-2">
            <button
                onclick="window.print()"
                class="bg-gray-100 text-gray-700 px-4 py-2 rounded-md hover:bg-gray-200 text-sm"
            >
                Print
            </button>
            <button
                onclick="savePlan()"
                class="bg-indigo-600 text-white px-4 py-2 rounded-md hover:bg-indigo-700 text-sm"
            >
                Save Plan
            </button>
        </div>
    </div>
</div>

<!-- Segment Template (hidden) -->
<template id="segment-template">
    <div class="segment border rounded-lg p-4 bg-gray-50" data-index="">
        <div class="flex justify-between items-start mb-3">
            <div class="flex-1 grid grid-cols-2 md:grid-cols-4 gap-3">
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Segment Name</label>
                    <input type="text" class="segment-name w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="e.g., Warm-up">
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Duration (sec)</label>
                    <input type="number" class="segment-duration w-full px-2 py-1 border border-gray-300 rounded text-sm" min="10" step="10" placeholder="180">
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Intensity</label>
                    <select class="segment-intensity w-full px-2 py-1 border border-gray-300 rounded text-sm">
                        <option value="low">Low</option>
                        <option value="medium">Medium</option>
                        <option value="high">High</option>
                    </select>
                </div>
                <div>
                    <label class="block text-xs font-medium text-gray-500 mb-1">Position</label>
                    <select class="segment-position w-full px-2 py-1 border border-gray-300 rounded text-sm">
                        <option value="seated">Seated</option>
                        <option value="standing">Standing</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-4 gap-3 mb-3">
            <div class="md:col-span-2">
                <label class="block text-xs font-medium text-gray-500 mb-1">Song</label>
                <div class="flex gap-1">
                    <input type="text" class="segment-song flex-1 px-2 py-1 border border-gray-300 rounded text-sm" placeholder="Song name - Artist">
                    <input type="hidden" class="segment-spotify-uri">
                    <input type="hidden" class="segment-song-duration-ms" value="0">
                    <button type="button" onclick="openSpotifySearch(this)" class="px-2 py-1 bg-green-500 text-white rounded text-xs hover:bg-green-600" title="Search Spotify">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.419 1.56-.299.421-1.02.599-1.559.3z"/></svg>
                    </button>
                </div>
                <span class="segment-tempo-display text-xs text-indigo-500 mt-1 inline-block hidden"></span>
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">Start (sec)</label>
                <input type="number" class="segment-song-start w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="1" placeholder="0" title="Start song at this second">
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">End (sec)</label>
                <input type="number" class="segment-song-end w-full px-2 py-1 border border-gray-300 rounded text-sm" min="0" step="1" placeholder="" title="Stop song at this second (blank = segment end)">
            </div>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-3 mb-3">
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">RPM Range</label>
                <input type="text" class="segment-bpm w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="e.g., 90-100">
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">&nbsp;</label>
                <label class="flex items-center gap-2 text-sm font-medium text-gray-600 cursor-pointer h-[30px]">
                    <input type="checkbox" class="segment-fade-out w-5 h-5 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500">
                    Fade out song
                </label>
            </div>
        </div>

        <div>
            <label class="block text-xs font-medium text-gray-500 mb-1">Coaching Cues</label>
            <textarea class="segment-description w-full px-2 py-1 border border-gray-300 rounded text-sm" rows="2" placeholder="Instructions and motivation..."></textarea>
        </div>

        <!-- Sub-segments Section -->
        <div class="sub-segments-section mt-3 border-t pt-3">
            <div class="flex justify-between items-center mb-2">
                <button type="button" onclick="toggleSubSegments(this)" class="text-xs text-indigo-600 hover:text-indigo-800 flex items-center gap-1">
                    <svg class="w-4 h-4 sub-segments-chevron transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                    </svg>
                    <span class="sub-segments-toggle-text">Sub-segments</span>
                    <span class="sub-segments-count text-gray-400">(0)</span>
                </button>
                <button type="button" onclick="addSubSegment(this)" class="text-xs bg-indigo-100 text-indigo-700 px-2 py-1 rounded hover:bg-indigo-200">
                    + Add Sub-segment
                </button>
            </div>
            <div class="sub-segments-container hidden space-y-2 ml-4 border-l-2 border-indigo-200 pl-3">
                <!-- Sub-segments will be added here -->
            </div>
        </div>

        <div class="flex justify-between items-center mt-2 text-xs text-gray-400">
            <span class="segment-time-marker"></span>
            <div class="flex items-center gap-1 sm:gap-3">
                <button onclick="moveSegment(this, -1)" class="hover:text-gray-600 p-1" title="Move Up">
                    <span class="hidden sm:inline">&uarr; Up</span>
                    <span class="sm:hidden">&uarr;</span>
                </button>
                <button onclick="moveSegment(this, 1)" class="hover:text-gray-600 p-1" title="Move Down">
                    <span class="hidden sm:inline">&darr; Down</span>
                    <span class="sm:hidden">&darr;</span>
                </button>
                <button onclick="removeSegment(this)" class="px-2 py-0.5 bg-red-100 text-red-600 hover:bg-red-200 hover:text-red-800 rounded font-medium" title="Remove segment">
                    <span class="hidden sm:inline">&times; Remove</span>
                    <span class="sm:hidden">&times;</span>
                </button>
            </div>
        </div>
    </div>
</template>

<!-- Sub-segment Template -->
<template id="sub-segment-template">
    <div class="sub-segment bg-indigo-50 rounded p-3 border border-indigo-100">
        <div class="grid grid-cols-2 md:grid-cols-4 gap-2 mb-2">
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">Name</label>
                <input type="text" class="sub-segment-name w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="e.g., Standing Sprint">
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">Duration (sec)</label>
                <input type="number" class="sub-segment-duration w-full px-2 py-1 border border-gray-300 rounded text-sm" min="5" step="5" placeholder="30">
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">Intensity</label>
                <select class="sub-segment-intensity w-full px-2 py-1 border border-gray-300 rounded text-sm">
                    <option value="low">Low</option>
                    <option value="medium">Medium</option>
                    <option value="high">High</option>
                </select>
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">Position</label>
                <select class="sub-segment-position w-full px-2 py-1 border border-gray-300 rounded text-sm">
                    <option value="seated">Seated</option>
                    <option value="standing">Standing</option>
                </select>
            </div>
        </div>
        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 mb-2">
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">RPM Range</label>
                <input type="text" class="sub-segment-bpm w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="e.g., 100-120">
            </div>
            <div>
                <label class="block text-xs font-medium text-gray-500 mb-1">Coaching Cues</label>
                <input type="text" class="sub-segment-description w-full px-2 py-1 border border-gray-300 rounded text-sm" placeholder="Quick instruction...">
            </div>
        </div>
        <div class="flex justify-end gap-2 text-xs">
            <button type="button" onclick="moveSubSegment(this, -1)" class="text-gray-500 hover:text-gray-700">&uarr; Up</button>
            <button type="button" onclick="moveSubSegment(this, 1)" class="text-gray-500 hover:text-gray-700">&darr; Down</button>
            <button type="button" onclick="removeSubSegment(this)" class="text-red-500 hover:text-red-700">&times; Remove</button>
        </div>
    </div>
</template>

<!-- Print View -->
<div id="print-view" class="hidden print:block">
    <div id="print-content"></div>
</div>

<!-- Spotify Search Modal -->
<div id="spotify-search-modal" class="fixed inset-0 bg-black bg-opacity-50 hidden z-50 flex items-center justify-center">
    <div class="bg-white rounded-lg shadow-xl w-full max-w-lg mx-4">
        <div class="p-4 border-b flex justify-between items-center">
            <h3 class="text-lg font-semibold">Search Spotify</h3>
            <button onclick="closeSpotifySearch()" class="text-gray-500 hover:text-gray-700 text-2xl">&times;</button>
        </div>
        <div class="p-4">
            <input
                type="text"
                id="spotify-search-input"
                class="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-green-500"
                placeholder="Search for a song..."
                onkeyup="debounceSearch(event)"
            >
            <div id="spotify-search-results" class="mt-4 max-h-64 overflow-y-auto">
                <p class="text-gray-500 text-center py-4">Enter a song name to search</p>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let plan = null;
    let currentPlanId = null;  // Track if editing existing plan
    const container = document.getElementById('segments-container');
    const template = document.getElementById('segment-template');
    const subSegmentTemplate = document.getElementById('sub-segment-template');

    // Check if we should show Spotify prompt (after AI generation)
    function checkSpotifyPrompt() {
        if (sessionStorage.getItem('showSpotifyPrompt') === 'true') {
            document.getElementById('spotify-prompt').classList.remove('hidden');
            sessionStorage.removeItem('showSpotifyPrompt');
        }
    }

    function dismissSpotifyPrompt() {
        document.getElementById('spotify-prompt').classList.add('hidden');
    }

    // Load plan from sessionStorage or URL
    function loadPlan() {
        const pathParts = window.location.pathname.split('/').filter(p => p);
        // URL is /plan/{id}/edit or /plan/new
        const planIndex = pathParts.indexOf('plan');
        const planId = planIndex >= 0 ? pathParts[planIndex + 1] : null;

        if (planId && planId !== 'new') {
            // Editing existing saved plan
            currentPlanId = planId;
            fetchPlan(planId);
        } else {
            // New plan - check sessionStorage
            const stored = sessionStorage.getItem('generatedPlan');
            if (stored) {
                plan = JSON.parse(stored);
                sessionStorage.removeItem('generatedPlan');
                renderPlan();
            } else {
                // No plan, redirect to generator
                window.location.href = '/';
            }
        }
    }

    async function fetchPlan(id) {
        try {
            const response = await fetch(`/api/plans/${id}`, {
                headers: { 'Authorization': 'Bearer placeholder' }
            });
            if (response.ok) {
                const data = await response.json();
                plan = data.plan_json;
                renderPlan();
            } else {
                window.location.href = '/';
            }
        } catch (error) {
            console.error('Failed to fetch plan:', error);
            window.location.href = '/';
        }
    }

    function renderPlan() {
        document.getElementById('plan-theme').value = plan.theme || '';
        document.getElementById('plan-notes').value = plan.notes || '';

        // Update back link if editing existing plan
        if (currentPlanId) {
            document.getElementById('back-links').innerHTML = `
                <a href="/plan/${currentPlanId}" class="text-gray-600 hover:text-gray-800">
                    &larr; Back to View
                </a>
                <span class="mx-2 text-gray-300">|</span>
                <a href="/" class="text-gray-600 hover:text-gray-800">New Plan</a>
            `;
        }

        container.innerHTML = '';
        plan.segments.forEach((segment, index) => {
            addSegmentElement(segment, index);
        });

        updateTotalDuration();
        updateTimeMarkers();

        // Fetch audio features for all segments with Spotify URIs
        loadAllAudioFeatures();
    }

    async function loadAllAudioFeatures() {
        const segments = container.querySelectorAll('.segment');
        segments.forEach((segmentEl) => {
            const spotifyUri = segmentEl.querySelector('.segment-spotify-uri').value;
            if (spotifyUri) {
                fetchAudioFeatures(segmentEl, spotifyUri);
            }
        });
    }

    function addSegmentElement(segment = null, index = null) {
        const clone = template.content.cloneNode(true);
        const el = clone.querySelector('.segment');

        if (segment) {
            el.querySelector('.segment-name').value = segment.name || '';
            el.querySelector('.segment-duration').value = segment.duration_seconds || 180;
            el.querySelector('.segment-intensity').value = segment.intensity || 'medium';
            el.querySelector('.segment-position').value = segment.position || 'seated';
            el.querySelector('.segment-song').value = segment.song || '';
            el.querySelector('.segment-spotify-uri').value = segment.spotify_uri || '';
            el.querySelector('.segment-song-start').value = segment.song_start_seconds || 0;
            el.querySelector('.segment-song-end').value = segment.song_end_seconds || '';
            el.querySelector('.segment-fade-out').checked = segment.fade_out === true;
            el.querySelector('.segment-bpm').value = segment.suggested_bpm_range || '';
            el.querySelector('.segment-description').value = segment.description || '';
            // Store song duration if we have one (duration_seconds * 1000 as approximation if from Spotify)
            if (segment.spotify_uri && segment.duration_seconds) {
                el.querySelector('.segment-song-duration-ms').value = segment.duration_seconds * 1000;
            }
        }

        // Add change listeners
        el.querySelectorAll('input, select, textarea').forEach(input => {
            input.addEventListener('change', () => {
                updateTotalDuration();
                updateTimeMarkers();
            });
        });

        // Add specific listeners for start/end time to recalculate duration
        el.querySelector('.segment-song-start').addEventListener('change', () => {
            recalculateSegmentDuration(el);
        });
        el.querySelector('.segment-song-end').addEventListener('change', () => {
            recalculateSegmentDuration(el);
        });

        container.appendChild(el);

        // Load sub-segments if present
        if (segment && segment.sub_segments && segment.sub_segments.length > 0) {
            const addedEl = container.lastElementChild;
            const subContainer = addedEl.querySelector('.sub-segments-container');
            segment.sub_segments.forEach(subSeg => {
                addSubSegmentElement(subContainer, subSeg);
            });
            updateSubSegmentCount(addedEl);
            // Auto-expand if has sub-segments
            subContainer.classList.remove('hidden');
            addedEl.querySelector('.sub-segments-chevron').classList.add('rotate-90');
        }
    }

    function addSegment() {
        addSegmentElement({
            name: 'New Segment',
            duration_seconds: 180,
            intensity: 'medium',
            position: 'seated',
            song: '',
            suggested_bpm_range: '100-120',
            description: ''
        });
        updateTotalDuration();
        updateTimeMarkers();
    }

    function removeSegment(btn) {
        const segment = btn.closest('.segment');
        segment.remove();
        updateTotalDuration();
        updateTimeMarkers();
    }

    function moveSegment(btn, direction) {
        const segment = btn.closest('.segment');
        const segments = Array.from(container.children);
        const index = segments.indexOf(segment);
        const newIndex = index + direction;

        if (newIndex >= 0 && newIndex < segments.length) {
            if (direction === -1) {
                container.insertBefore(segment, segments[newIndex]);
            } else {
                container.insertBefore(segments[newIndex], segment);
            }
            updateTimeMarkers();
        }
    }

    function updateTotalDuration() {
        const segments = container.querySelectorAll('.segment');
        let total = 0;
        segments.forEach(seg => {
            total += parseInt(seg.querySelector('.segment-duration').value) || 0;
        });
        const minutes = Math.floor(total / 60);
        document.getElementById('total-duration').textContent = `${minutes} min`;
    }

    function updateTimeMarkers() {
        const segments = container.querySelectorAll('.segment');
        let runningTime = 0;
        segments.forEach((seg, i) => {
            const marker = seg.querySelector('.segment-time-marker');
            const duration = parseInt(seg.querySelector('.segment-duration').value) || 0;
            marker.textContent = `${formatTime(runningTime)} - ${formatTime(runningTime + duration)}`;
            runningTime += duration;
        });
    }

    function formatTime(totalSeconds) {
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Sub-segment functions
    function toggleSubSegments(btn) {
        const segment = btn.closest('.segment');
        const container = segment.querySelector('.sub-segments-container');
        const chevron = segment.querySelector('.sub-segments-chevron');
        container.classList.toggle('hidden');
        chevron.classList.toggle('rotate-90');
    }

    function addSubSegment(btn) {
        const segment = btn.closest('.segment');
        const container = segment.querySelector('.sub-segments-container');
        addSubSegmentElement(container);
        updateSubSegmentCount(segment);
        // Auto-expand when adding first sub-segment
        if (container.classList.contains('hidden')) {
            container.classList.remove('hidden');
            segment.querySelector('.sub-segments-chevron').classList.add('rotate-90');
        }
        recalculateSegmentDurationFromSubSegments(segment);
    }

    function addSubSegmentElement(container, subSegment = null) {
        const clone = subSegmentTemplate.content.cloneNode(true);
        const el = clone.querySelector('.sub-segment');

        if (subSegment) {
            el.querySelector('.sub-segment-name').value = subSegment.name || '';
            el.querySelector('.sub-segment-duration').value = subSegment.duration_seconds || 30;
            el.querySelector('.sub-segment-intensity').value = subSegment.intensity || 'medium';
            el.querySelector('.sub-segment-position').value = subSegment.position || 'seated';
            el.querySelector('.sub-segment-bpm').value = subSegment.suggested_bpm_range || '';
            el.querySelector('.sub-segment-description').value = subSegment.description || '';
        } else {
            // Default values for new sub-segment
            el.querySelector('.sub-segment-duration').value = 30;
            el.querySelector('.sub-segment-intensity').value = 'medium';
            el.querySelector('.sub-segment-position').value = 'seated';
        }

        // Add change listeners for duration recalculation
        el.querySelectorAll('input, select').forEach(input => {
            input.addEventListener('change', () => {
                const segment = container.closest('.segment');
                recalculateSegmentDurationFromSubSegments(segment);
                updateTotalDuration();
                updateTimeMarkers();
            });
        });

        container.appendChild(el);
    }

    function removeSubSegment(btn) {
        const subSegment = btn.closest('.sub-segment');
        const segment = subSegment.closest('.segment');
        const container = segment.querySelector('.sub-segments-container');
        subSegment.remove();
        updateSubSegmentCount(segment);
        recalculateSegmentDurationFromSubSegments(segment);
        updateTotalDuration();
        updateTimeMarkers();
    }

    function moveSubSegment(btn, direction) {
        const subSegment = btn.closest('.sub-segment');
        const container = subSegment.parentElement;
        const subSegments = Array.from(container.children);
        const index = subSegments.indexOf(subSegment);
        const newIndex = index + direction;

        if (newIndex >= 0 && newIndex < subSegments.length) {
            if (direction === -1) {
                container.insertBefore(subSegment, subSegments[newIndex]);
            } else {
                container.insertBefore(subSegments[newIndex], subSegment);
            }
        }
    }

    function updateSubSegmentCount(segment) {
        const count = segment.querySelectorAll('.sub-segment').length;
        segment.querySelector('.sub-segments-count').textContent = `(${count})`;
    }

    function recalculateSegmentDurationFromSubSegments(segment) {
        const subSegments = segment.querySelectorAll('.sub-segment');
        if (subSegments.length === 0) return;

        let totalDuration = 0;
        subSegments.forEach(sub => {
            totalDuration += parseInt(sub.querySelector('.sub-segment-duration').value) || 0;
        });

        segment.querySelector('.segment-duration').value = totalDuration;
    }

    function collectSubSegments(segment) {
        const subSegments = [];
        segment.querySelectorAll('.sub-segment').forEach(sub => {
            subSegments.push({
                name: sub.querySelector('.sub-segment-name').value,
                duration_seconds: parseInt(sub.querySelector('.sub-segment-duration').value) || 0,
                intensity: sub.querySelector('.sub-segment-intensity').value,
                position: sub.querySelector('.sub-segment-position').value,
                suggested_bpm_range: sub.querySelector('.sub-segment-bpm').value,
                description: sub.querySelector('.sub-segment-description').value,
            });
        });
        return subSegments.length > 0 ? subSegments : null;
    }

    function collectPlanData() {
        const segments = [];
        container.querySelectorAll('.segment').forEach(seg => {
            const songEnd = seg.querySelector('.segment-song-end').value;
            segments.push({
                name: seg.querySelector('.segment-name').value,
                duration_seconds: parseInt(seg.querySelector('.segment-duration').value) || 0,
                intensity: seg.querySelector('.segment-intensity').value,
                position: seg.querySelector('.segment-position').value,
                song: seg.querySelector('.segment-song').value,
                spotify_uri: seg.querySelector('.segment-spotify-uri').value,
                song_start_seconds: parseInt(seg.querySelector('.segment-song-start').value) || 0,
                song_end_seconds: songEnd ? parseInt(songEnd) : null,
                fade_out: seg.querySelector('.segment-fade-out').checked,
                suggested_bpm_range: seg.querySelector('.segment-bpm').value,
                description: seg.querySelector('.segment-description').value,
                sub_segments: collectSubSegments(seg),
            });
        });

        let totalSeconds = 0;
        segments.forEach(s => totalSeconds += s.duration_seconds);

        return {
            theme: document.getElementById('plan-theme').value,
            total_duration_minutes: Math.ceil(totalSeconds / 60),
            segments: segments,
            notes: document.getElementById('plan-notes').value || null
        };
    }

    async function savePlan() {
        const planData = collectPlanData();

        try {
            // Use PUT for existing plans, POST for new
            const url = currentPlanId ? `/api/plans/${currentPlanId}` : '/api/plans';
            const method = currentPlanId ? 'PUT' : 'POST';

            const response = await fetch(url, {
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': 'Bearer placeholder'
                },
                body: JSON.stringify({ plan: planData })
            });

            if (response.ok) {
                const data = await response.json();
                const planId = data.id || currentPlanId;
                showToast('Plan saved successfully!');
                setTimeout(() => {
                    window.location.href = `/plan/${planId}`;
                }, 500);
            } else {
                throw new Error('Failed to save plan');
            }
        } catch (error) {
            showToast('Error saving plan: ' + error.message, 'error');
        }
    }

    // Auto-refresh Spotify token and retry request
    async function spotifyFetch(url, options = {}, retried = false) {
        const response = await fetch(url, options);

        if (response.status === 401 && !retried) {
            const refreshResponse = await fetch('/api/spotify/refresh', { method: 'POST' });
            if (refreshResponse.ok) {
                return spotifyFetch(url, options, true);
            }
        }

        return response;
    }

    // Fetch audio features from Spotify for a segment
    async function fetchAudioFeatures(segmentEl, spotifyUri) {
        // Extract track ID from URI (spotify:track:TRACK_ID)
        const trackId = spotifyUri.split(':').pop();
        if (!trackId) return;

        try {
            const response = await spotifyFetch(`/api/spotify/audio-features/${trackId}`);
            if (!response.ok) return;

            const data = await response.json();
            const tempoDisplay = segmentEl.querySelector('.segment-tempo-display');
            if (tempoDisplay && (data.tempo || data.energy)) {
                const parts = [];
                if (data.tempo) {
                    const source = data.energy ? '' : 'GetSongBPM Tempo: ';
                    parts.push(`${source}${data.tempo} BPM`);
                }
                if (data.energy) parts.push(`Energy ${data.energy}%`);
                if (data.valence) parts.push(`Mood ${data.valence}%`);
                if (data.danceability) parts.push(`Dance ${data.danceability}%`);
                tempoDisplay.textContent = parts.join(' Â· ');
                tempoDisplay.classList.remove('hidden');
            }
        } catch (error) {
            // Silently fail - audio features unavailable
        }
    }

    // Spotify Search
    let currentSegmentForSearch = null;
    let searchTimeout = null;

    function openSpotifySearch(btn) {
        currentSegmentForSearch = btn.closest('.segment');
        const modal = document.getElementById('spotify-search-modal');
        const input = document.getElementById('spotify-search-input');
        const results = document.getElementById('spotify-search-results');

        // Pre-fill with current song name
        const currentSong = currentSegmentForSearch.querySelector('.segment-song').value;
        input.value = currentSong;
        results.innerHTML = '<p class="text-gray-500 text-center py-4">Enter a song name to search</p>';

        modal.classList.remove('hidden');
        input.focus();

        if (currentSong) {
            searchSpotify(currentSong);
        }
    }

    function closeSpotifySearch() {
        document.getElementById('spotify-search-modal').classList.add('hidden');
        currentSegmentForSearch = null;
    }

    function debounceSearch(event) {
        clearTimeout(searchTimeout);
        const query = event.target.value.trim();

        if (query.length < 2) {
            document.getElementById('spotify-search-results').innerHTML =
                '<p class="text-gray-500 text-center py-4">Enter a song name to search</p>';
            return;
        }

        searchTimeout = setTimeout(() => searchSpotify(query), 300);
    }

    async function searchSpotify(query) {
        const results = document.getElementById('spotify-search-results');
        results.innerHTML = '<p class="text-gray-500 text-center py-4">Searching...</p>';

        try {
            const response = await spotifyFetch(`/api/spotify/search?q=${encodeURIComponent(query)}`);

            if (response.status === 401) {
                results.innerHTML = `
                    <div class="text-center py-4">
                        <p class="text-gray-600 mb-2">Connect Spotify to search songs</p>
                        <a href="/api/spotify/login" class="inline-block bg-green-500 text-white px-4 py-2 rounded-md hover:bg-green-600">
                            Connect Spotify
                        </a>
                    </div>
                `;
                return;
            }

            const data = await response.json();

            if (data.tracks.length === 0) {
                results.innerHTML = '<p class="text-gray-500 text-center py-4">No songs found</p>';
                return;
            }

            results.innerHTML = data.tracks.map(track => `
                <div class="flex items-center gap-3 p-2 hover:bg-gray-100 rounded cursor-pointer" onclick="selectTrack('${track.uri}', '${escapeAttr(track.name)}', '${escapeAttr(track.artist)}', ${track.duration_ms}, ${track.tempo || 0}, ${track.energy || 0}, ${track.valence || 0}, ${track.danceability || 0})">
                    ${track.image ? `<img src="${track.image}" class="w-10 h-10 rounded" alt="">` : '<div class="w-10 h-10 bg-gray-200 rounded"></div>'}
                    <div class="flex-1 min-w-0">
                        <p class="font-medium text-sm truncate">${escapeHtml(track.name)}</p>
                        <p class="text-xs text-gray-500 truncate">${escapeHtml(track.artist)}</p>
                    </div>
                    <div class="text-right text-xs">
                        <div class="text-gray-400">${formatDuration(track.duration_ms)}${track.tempo ? ` &middot; ${track.tempo} BPM` : ''}</div>
                        ${track.energy ? `<div class="text-gray-500">Energy ${track.energy}% &middot; Mood ${track.valence}%</div>` : ''}
                    </div>
                </div>
            `).join('');

        } catch (error) {
            results.innerHTML = '<p class="text-red-500 text-center py-4">Search failed</p>';
        }
    }

    function selectTrack(uri, name, artist, durationMs, tempo, energy, valence, danceability) {
        if (!currentSegmentForSearch) return;

        currentSegmentForSearch.querySelector('.segment-song').value = `${name} - ${artist}`;
        currentSegmentForSearch.querySelector('.segment-spotify-uri').value = uri;
        currentSegmentForSearch.querySelector('.segment-song-duration-ms').value = durationMs || 0;

        // Update segment duration to match song duration
        if (durationMs) {
            const durationSeconds = Math.floor(durationMs / 1000);
            currentSegmentForSearch.querySelector('.segment-duration').value = durationSeconds;
            // Clear start/end times when selecting new song
            currentSegmentForSearch.querySelector('.segment-song-start').value = 0;
            currentSegmentForSearch.querySelector('.segment-song-end').value = '';
            updateTotalDuration();
            updateTimeMarkers();
        }

        // Fetch audio features asynchronously
        fetchAudioFeatures(currentSegmentForSearch, uri);

        closeSpotifySearch();
    }

    function recalculateSegmentDuration(segmentEl) {
        const songDurationMs = parseInt(segmentEl.querySelector('.segment-song-duration-ms').value) || 0;
        if (!songDurationMs) return; // No song selected, don't auto-calculate

        const songDurationSec = Math.floor(songDurationMs / 1000);
        const startTime = parseInt(segmentEl.querySelector('.segment-song-start').value) || 0;
        const endTimeInput = segmentEl.querySelector('.segment-song-end').value;
        const endTime = endTimeInput ? parseInt(endTimeInput) : songDurationSec;

        // Validate start/end times
        const validStart = Math.max(0, Math.min(startTime, songDurationSec));
        const validEnd = Math.max(validStart, Math.min(endTime, songDurationSec));

        // Update the inputs if they were invalid
        segmentEl.querySelector('.segment-song-start').value = validStart;
        if (endTimeInput) {
            segmentEl.querySelector('.segment-song-end').value = validEnd;
        }

        // Calculate and set duration
        const duration = validEnd - validStart;
        segmentEl.querySelector('.segment-duration').value = duration;

        updateTotalDuration();
        updateTimeMarkers();
    }

    function escapeHtml(text) {
        if (!text) return '';
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    function escapeAttr(text) {
        if (!text) return '';
        return text.replace(/'/g, "\\'").replace(/"/g, '\\"');
    }

    function formatDuration(ms) {
        const minutes = Math.floor(ms / 60000);
        const seconds = Math.floor((ms % 60000) / 1000);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }

    // Close modal on escape key
    document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') closeSpotifySearch();
    });

    // Initialize
    loadPlan();
    checkSpotifyPrompt();
</script>

<style>
    @media print {
        #plan-editor {
            display: none;
        }
        #print-view {
            display: block !important;
        }
    }
</style>
{% endblock %}
